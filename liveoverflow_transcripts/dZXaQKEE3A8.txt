All The Little Things was a harder webÂ 
challenge from the Google CTF 2020.
In the end only 20 teams solved it.Â 
This challenge is almost like a part
2 from the easy pasteurize challenge,Â 
so make sure you have seen that too.
As it is with most harder challenges this alsoÂ 
was a team effort. multiple people of our team
ALLES! contributed to the solution.Â 
So, let me tell you how we solved it.

â€œI left a little secret in a note, butÂ 
it's private, private is safe.â€ and â€œNote:
TJMikeğŸ¤ from Pasteurize is also logged intoÂ 
the page.â€. This already tells us that,
like pasteurize, this is a browser client sideÂ 
hacking challenge. So XSS, CSRF, that kinda stuff.
So letâ€™s start by checking out the functionality.
We can login by using a username
and a profile image URL.
The image is then embedded up there. And
we can access settings. Notes and logout.
In settings we can change the name,
profile picture and theme. ThereÂ 
is dark-mode and light mode.
Then there is â€œnoteâ€ where we can create a newÂ 
note. And we can make it private or public.
If we make a public note, just as a test submitÂ 
anything, it shows up in our list of notes, but it
actually redirects to the pasteurize challenge.Â 
So public notes are submitted on pasteurize.
Letâ€™s go back to the littlethingsÂ 
domain and make a private note instead.
Like with pasteurize we could try some XSSÂ 
payload. A HTML tag and an image tag with onerror.
Submit it and then it shows up in our list ofÂ 
notes. And private notes are now displayed on
the littlethings domain. AS with pasteurizeÂ 
some HTML got rendered, but only what is
safe. The onerror handler of the image wasÂ 
removed. When we look into the static page
sources we can see that it basically looks theÂ 
same like pasteurize. Here is the note content,
including the XSS payload, and then it is passedÂ 
into DOMpurify.sanitize(). Which we know is safe.
We could also try the trick from pasteurizeÂ 
for the XSS, but it doesnâ€™t work. In fact
after the CTF, the author of the challengeÂ 
shared that the vulnerability in pasteurize
was actually first in this challenge â€œall theÂ 
little thingsâ€, but it was an easy unintended
bypass, so he fixed it, and created pasteurizeÂ 
as an easy introduction challenge with this bug.
Anyway. After that I just started looking throughÂ 
all the given sources. Mainly the utils.js,
user.js and theme.js. Those are the customÂ 
javascript code to make this website work.
And if we try to find some kind ofÂ 
XSS, itâ€™s probably somewhere in there.
And the code turns out to be really fishy.Â 
So there was already a feeling for, â€œyeah,
this looks so weird, there must be issues here.â€
For example in theme.js, the update_theme()
function takes the configured theme fromÂ 
the document.username object. Then creates
a script tag, where it embeds this theme URL withÂ 
a cb parameter. If we look at the requests sent
when you load a page, you can see that a themeÂ 
could be for example set_light_theme, and then
the response of this URL looks like this. So thisÂ 
is a JSONP api endpoint. I briefly introduced
JSONP and how it can lead to issues in the GoogleÂ 
Sheets XSS video. So watch that if you want some
additional information. Here this script simplyÂ 
uses the callback parameter as a function name,
to call this function. So when embedding thisÂ 
as a script, it will call set_light_theme,
which is defined in theme.js as well. And thisÂ 
function simply updates the .css of this page.
The callback parameter can also be kinda freelyÂ 
chosen. So for example we could enter here
alert(), and now we have a script, hosted on theÂ 
littlethings website that calls alert. And this
will become important soon. Letâ€™s remember that.
Other than that we have a user.js file,
which contains a user class. A user has aÂ 
name, an image and a theme. In the function
make_user_object this user is created. TheÂ 
image source of the profile image is set,
and also update_theme() is called. There is alsoÂ 
this weird load_debug function call, but we donâ€™t
know what that is for now. Just fyi, the questionÂ 
mark is a special syntax that basically means.
If load_debug is undefined, do nothing,Â 
if it exists, call it as a function. So
this is just a shorthand to make sure thereÂ 
is no error if the function doesnâ€™t exist.
And then we come to utils.js, and this looks likeÂ 
the start of everything. It triggers when the DOM
of the website is loaded. And it triggers a fetchÂ 
request to /me, which turns out to respond with
the user data in a JSON format, it then takesÂ 
the json and calls make_user_object on it. So
that triggers the chain of creating the user andÂ 
then updating the theme with the JSONP callback.
At this point we were still missing one importantÂ 
detail that we missed. We thought we explored
everything, but we didnâ€™t. Regardless, weÂ 
started to think about possible exploits.
We knew the goal is to accessÂ 
a private note of TJMike.
He must have a private note with the flagÂ 
in it. We didnâ€™t have full XSS anywhere yet,
but we knew it must be browser clientÂ 
side related. So we started to experiment.
The notes did allow some HTML. NotÂ 
javascript, no XSS, but it allowed
html tags. And there is a technique called DOMÂ 
clobbering using HTML id and name attributes.
Here is an example. letâ€™s create a note with aÂ 
div using an id like â€œblaâ€. This is definitely
allowed, as it is not XSS. But this doesÂ 
something to the DOM. If we go into the
javascript console, we can access this HTML tagÂ 
via window.bla. Window.bla points to our div.
Notice something? Remember the window.load_debugÂ 
that is checked if it is undefined or not?
We could create an HTML tag with theÂ 
id â€œload_debugâ€, and then it exists!
Letâ€™s try it. Submit it. And here it is.Â 
If we look now into the javascript console,
we can find an error, â€œwindow.load_debug is notÂ 
a functionâ€. Which makes sense, because it is an
HTMLDivElement object. So I thought â€œmaybe thereÂ 
is a trick. Maybe there is a weird HTML element,
that is also a valid function!â€ This is aÂ 
very wild idea, I would have never thought
to check something like this, if it werenâ€™tÂ 
for this challenge. Finding such an HTML
element could be a very cool DOM clobber trick.
So letâ€™s do some security research. Letâ€™s try to
find such an element. First I looked up a big listÂ 
of possible HTML elements on github. I just took
a random list. Donâ€™t even know if itâ€™s complete.Â 
Then I put it into a javascript array and looped
over each element. On our notes we know thatÂ 
script tags are removed by DOMPurify. So for
each tag I call DOMPurify sanitize on it, justÂ 
to make sure it is allowed and gets through.
The element I create also gets the id=x, so thatÂ 
we can then try to call window.x as a function.
This is all inside a try-catch, because mostÂ 
likely this wonâ€™t work and throws an error.
Window.x is not a function. But if itÂ 
survives the function call, we print found!
Now I simply execute this code in the developerÂ 
console. It super quickly runs through. And finds
nothing. Crapâ€¦ Oh wellâ€¦ This is a typicalÂ 
â€œdumbâ€ idea you might have, you test it,
and you find out it doesnâ€™t work. But thatâ€™sÂ 
security research. I think it was a good idea
and worth testing for. Now we know, thisÂ 
probably is not the path to the solution.
After that we continued looking for otherÂ 
things we could clobber. I mean there is
window.USERNAME, but itâ€™s assigned here,Â 
so it would overwrite our clobbered value.
Or here is a querySelector for the idÂ 
bootstrap-link, which we could also try to include
into our note, but this code is actually executedÂ 
BEFORE it renders the note, so it doesnâ€™t work.
And even if it would set the href, IÂ 
donâ€™t really know if it would help us.
So we were kinda stuck.
â€¦
I started to get a bit frustrated when I clickedÂ 
through all the sources again, and then I noticed
this __debug__ get parameter. This is theÂ 
small important detail I missed earlier.
Adding this to the URL, it will add aÂ 
new debug.js script! And it also adds
some additional HTML into the settings page.
This debug.js script actually defines
the load_debug function! It takes theÂ 
window.name, interprets this string as JSON
and, this line, the Object.assign(), mergesÂ 
this debug JSON object with the user object!
It then has some additional features, you can turnÂ 
verbose mode on, show all hidden HTML elements,
and keepDebug, which adds the __debug__ GETÂ 
parameter to all anchor href links that it finds.
onerror is also overwritten with alert.
This obviously gets us forward. So withÂ 
debug turned on we get this debug input
form in the settings. All this does is, youÂ 
can write there some JSON and it will set the
window.name to this JSON as a string. SoÂ 
letâ€™s write some JSON that sets verbose,
showAll and keepDebug onto the user object.Â 
Refresh the page. And now you see it change a bit,
because things like showALL revealedÂ 
all hidden elements and made them
blocks, we can also see here the hidden inputÂ 
CSRF token, and so forth. So this worked.
window.name is now set to this JSON string. UponÂ 
every page load, if the __debug__parameter is set,
the debug.js script with the load_debugÂ 
function reads, parses the string as JSON,
and then applies it to the user. and then theseÂ 
attributes become available on the user object.
And for those that donâ€™tÂ 
know, window.name is special.
Becauseâ€¦ See what happens if I go toÂ 
a different website in the same tab.
Liveoverflow.com. And now check theÂ 
window.name. IT IS STILL THE SAME. window.name
persists across other websites.
This gives us an entry path.
The video is getting quite long and thereÂ 
was so much info input already. I think
this is a good moment to stop. If youÂ 
havenâ€™t solved this challenge yourself,
now is a good point to try again. You can findÂ 
the link to the challenge in the description.
But there are still a few more little tricksÂ 
involved. But letâ€™s talk about it next video.
