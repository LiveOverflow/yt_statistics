How would I learn Reverse Engineering in 2022? To 
learn anything you need to practice. And spending
time on something, always trumps looking for the 
best tutorial or tool. Just get started. But there
is one thing I believe that really really helps. 
Especially when you get started. Let me show you

Back in 2016 I worked on my Binary Exploitation 
playlist and of course before we can
go into buffer overflows and other memory 
corruption exploits, I had to provide a
quick intro to programming and assembly. 
We somehow need to understand how computers
work in order to attack them. And especially 
episode 0x10 “Reverse engineering C programs”,
I show a technique that I find invaluable. 
And that is simply comparing source code,
to the assembly code that is generated. This 
video was mostly about comparing 32bit and 64
bit but more generally it is about the process 
of how you can figure stuff out for yourself.
You know there are kinda two ways how to do 
tutorials, one kind just tells you facts.
“teacher-centred teaching“. But the much more 
effective technique is one where students
themselves “research” and discover a topic. 
So here for example I wrote a basic C program,
and then compiled it in 32bit and 64bit, and then 
we look at the assembly code. And we can simply
look at how C code translates to the different 
assembly code. Not only do we learn about how
C code looks in assembly, but we automatically 
also learn how to do reverse engineering.
For example here I’m creating an integer 
`a` with the value 0x1234, and we can see
that in the assembly code as well. So we 
have here a MOVE instruction that moves
the recognizable value 0x1234 into a memory 
location relative to the stack. In 64bit at
a negative offset from the base pointer, and in 
32bit at a positive offset from the stack pointer.
So simply by playing around like this 
you can learn reverse engineering.
Try to remember that a line like this probably 
means in the C code you created a variable.
And this process is I think very powerful. So now 
let me show you two amazing tools that make this
process even more playful and effective. Let’s 
start with godbolt.org. The Compiler Explorer.
So on the left you can put for example C code,
and on the right you can see the assembly 
code generated by various compilers.
Let me paste in one of the example codes 
I used in my binary exploitation playlist.
A very basic license key check.
And see how amazing this is? So let’s
make sure we have C code selected and we can see 
we use the gcc compiler version 12 to compile it.
Hovering over the lines also shows you which 
C line is responsible for what assembly code.
Hovering over the function name and parameters, 
we can see that all of this is just “junk code”
it’s just function setup code. So if you want 
to reverse engineer the actual algorithm,
you now know code like this is maybe not 
that important. The first actual line of code
is the comparison if argc==2. And here 
is how that is implemented in assembly.
DWORD PTR might be confusing. Ignore DWORD 
and PTR. But these brackets are important.
This means its referencing a memory area. 
And the value inside is the address.
Imagine it kinda like the memory 
of a computer being a HUGE ARRAY,
then to access a value in the array we have this 
index. And the index is calculated from rbp,
the base pointer register, this contains an 
absolute address, but it takes an offset from
that -36. So it compares that memory value 
with the value 2. And then we have a JNE,
so either the code continues here, or we jump 
to L2, which is all the way at the bottom.
If we pass the check we go into the if case and 
we have a printf. And now we can also see here
how the function call to printf 
is prepared, specifically how
are the parameters passed to printf.
At the end we can see a call to printf,
so the CPU will now jump to the printf function 
implementation, but the arguments are prepared
before it. One argument is for example the 
prints tring itself “Checking License”,
and it’s here moved into edi. So now we know, on 
64bit, if we call a function, the first parameter
is probably going to be loaded into edi, or rdi.
So next time you see a “call”, look at the
assembly before and if you see a move into rdi, 
it’s probably the first parameter of the function.
Anyway. You can spend hours on here 
just looking at how different C
code is looking in assembly and 
it’s really really valuable.
But it can do even more. We can add another 
compiler here. For example an ARM compiler.
This was just intel assembly, but nowadays more 
and more devices run on ARM. For example mobile
phones or the new macbooks. So maybe it’s 
time to learn some ARM assembly. And if you
are already familiar with intel assembly, 
you can use this to learn how to read ARM.
Like you don’t even need any ARM specific 
tutorial, just look at the comparison.
The space is a bit limited on a small 
screen like here, so make sure you do
this on a bigger monitor, but look at 
for example the comparison. If argc==2.
So apparently ARM cannot do a direct comparison 
of the memory area. Instead we first LOAD argc
from memory into the r3 register, and 
then we compare r3 to the value 2. And
then we have a BRANCH not equal. Which 
is the equivalent to a JUMP NOT EQUAL.
Another tip is to look at not only the assembly, 
but the actual binary being created. So here in
the compiler settings you can enable “Compile 
to binary” and now you see the actual binary
code that corresponds to each instruction. 
And now all the jumps are not based on thes
assembly labels but have actual function names and 
offset and addresses. And also the printf call,
we can see now the actual address of the printf 
format string being moved into the edi register.
But we can do so much more. Lets look at 
the impact of the -O3 compiler option.
This enables aggressive optimization in gcc. 
And look at the restul. The complete function
setup part is now missing. The compiler 
realized it doesn’t really need it. Also
remember how we learned earlier that the FIRST 
parameter to a function is passed in EDI or RDI?
Well, main is also a function. So the value 
of argc is of course in RDI. And in the
non-optimized assembly we can see that at the 
start of the function edi is moved into this
local variable location on the stack and then that 
location is used to compare against value two.
BUT OF COURSE THIS CAN BE OPTIMIZED. We can 
just directly compare edi to the value 0x2.
It’s amazing how much you can learn 
just from playing around with this.
But the real reason why I wanted to make this 
video is because of another tool that was just
released by Vector35 and HexRays. They are 
the developers of BinaryNinja and IDA Pro.
To get to the tool you have to reverse engineer 
godbolt…. It’s a bit tricky. But what you have to
do is…. Take these three letters, “god” and then 
reverse them to “dog”... there we go! DOGBOLT!
The recompiler explorer. It’s kinda similar in the 
sense that you can compare different DECOMPILERS.
Here you really need a bigger monitor. But We 
can select here a CTF challenge example from the
samples and look at the different output Binary 
Ninja, Ghidra and Hex-Rays produce. And a few
other tools. So let’s go to main and have a look.
All three tools decompiled the same CTF challenge
binary. Sometimes these decompile outputs are 
hard to read, but again you can learn here how
to read this code. And if a line is confusing to 
you, you can also check what the other tool did.
For example as a beginner this call to 
__stack_chk_fail might be confusing, what
does that do? But it’s missing in IDAs output. 
This kinda makes sense because this function is
actually part of an exploit mitigation, 
stack canaries, so to reverse engineer
the functionality it’s not really useful to 
see. And IDA nicely hides it. On the other
hand maybe you want to see it. It all depends 
on the usecase. I’m sure there is a setting
in full IDA pro to make this show up as well.
Anyway. We can see that the code calls fgets,
so the user can enter a string, it then 
is in this variable, and the we call
“encrypt()”. And if the output of encrypt 
is true, so not 0., then we call print flag.
And here is the encrypt function.
IDA again produces a pretty beautiful
minimal decompile output, and binary ninja 
looks kinda scary. But you can also clean
that up by hand, and remove these type 
casts. Then it will be pretty similar.
Anyway. I'm too lazy to solve this challenge 
now. SO I leave it as an exercise to you.
I hope you agree, Both these 
tools are really amazing,
especially when you are starting out. It’s 
also awesome for basic CTF challenges.
Big shoutout to those companies 
creating such a free tool.
This video not sponsored by the way. 
I just think this is extremely useful.
I hope this helps learning 
reverse engineering in 2022
